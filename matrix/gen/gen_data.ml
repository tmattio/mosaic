(* gen_unicode_width_data.ml *)

let max_cp = 0x10FFFF
let u_of_int cp = if Uchar.is_valid cp then Some (Uchar.of_int cp) else None
let unicode_version = Uucp.unicode_version

(* --- Width Classification (for terminal cells) --- *)

let is_regional_indicator cp = cp >= 0x1F1E6 && cp <= 0x1F1FF

let classify_width cp =
  if is_regional_indicator cp then `Other
  else
    match u_of_int cp with
    | None -> `Other
    | Some u -> (
        match Uucp.Break.tty_width_hint u with
        | -1 -> `Control
        | 0 -> `Zero
        | 2 -> `Wide
        | _ -> `Other)

let is_control cp = classify_width cp = `Control
let is_zero cp = classify_width cp = `Zero
let is_wide cp = classify_width cp = `Wide

(* --- Grapheme Cluster Break Properties (UAX #29) --- *)

let has_gcb prop cp =
  match u_of_int cp with
  | None -> false
  | Some u -> Uucp.Break.grapheme_cluster u = prop

(* Uucp uses abbreviated tags for Grapheme_Cluster property *)
let is_extend = has_gcb `EX
let is_spacing_mark = has_gcb `SM
let is_prepend = has_gcb `PP
let is_hangul_l = has_gcb `L
let is_hangul_v = has_gcb `V
let is_hangul_t = has_gcb `T

(* --- Emoji Properties --- *)

let extended_pictographic_overrides = [ 0x2701 ]

let is_extended_pictographic cp =
  match u_of_int cp with
  | None -> false
  | Some u ->
      Uucp.Emoji.is_extended_pictographic u
      || List.mem cp extended_pictographic_overrides

let is_emoji_presentation cp =
  if is_regional_indicator cp then false
  else
    match u_of_int cp with
    | None -> false
    | Some u -> Uucp.Emoji.is_emoji_presentation u

(* --- Indic Conjunct Break Properties (GB9c) --- *)

let has_incb prop cp =
  match u_of_int cp with
  | None -> false
  | Some u -> Uucp.Break.indic_conjunct_break u = prop

(* Uucp uses full names for Indic_Conjunct_Break property *)
let is_incb_linker = has_incb `Linker
let is_incb_consonant = has_incb `Consonant
let is_incb_extend = has_incb `Extend

(* --- Generation Logic --- *)

let collect_ranges cond =
  let rec loop cp current acc =
    if cp > max_cp then
      match current with
      | None -> List.rev acc
      | Some (s, e) -> List.rev ((s, e) :: acc)
    else
      let next = cp + 1 in
      if cond cp then
        match current with
        | None -> loop next (Some (cp, cp)) acc
        | Some (s, _) -> loop next (Some (s, cp)) acc
      else
        match current with
        | None -> loop next None acc
        | Some range -> loop next None (range :: acc)
  in
  loop 0 None []

let write_array oc name ranges =
  Printf.fprintf oc "let %s = [|" name;
  List.iter (fun (s, e) -> Printf.fprintf oc " (%d, %d);" s e) ranges;
  output_string oc " |]\n"

let () =
  if Array.length Sys.argv <> 2 then failwith "expected output path";
  let path = Sys.argv.(1) in
  let oc = open_out path in

  output_string oc
    "(* Generated by gen_unicode_width_data.ml *)\n\
     [@@@ocamlformat \"disable\"]\n\n";
  Printf.fprintf oc "let unicode_version = %S\n\n" unicode_version;

  (* Width Calculation Ranges (for Glyph.ml / calculate_width) *)
  write_array oc "control_ranges" (collect_ranges is_control);
  write_array oc "combining_ranges" (collect_ranges is_zero);
  write_array oc "wide_ranges" (collect_ranges is_wide);
  write_array oc "emoji_extended_ranges"
    (collect_ranges is_extended_pictographic);
  write_array oc "emoji_presentation_ranges"
    (collect_ranges is_emoji_presentation);
  output_string oc "\n";

  (* Grapheme Segmentation Ranges (for grapheme_cluster.ml / UAX #29) *)
  write_array oc "range_extend" (collect_ranges is_extend);
  write_array oc "range_spacing_mark" (collect_ranges is_spacing_mark);
  write_array oc "range_prepend" (collect_ranges is_prepend);

  (* Re-export extended pictographic with the name expected by grapheme_cluster.ml *)
  write_array oc "range_extended_pictographic"
    (collect_ranges is_extended_pictographic);

  (* Hangul *)
  write_array oc "range_hangul_l" (collect_ranges is_hangul_l);
  write_array oc "range_hangul_v" (collect_ranges is_hangul_v);
  write_array oc "range_hangul_t" (collect_ranges is_hangul_t);

  (* Indic Conjunct Break (GB9c) *)
  write_array oc "range_incb_linker" (collect_ranges is_incb_linker);
  write_array oc "range_incb_consonant" (collect_ranges is_incb_consonant);
  write_array oc "range_incb_extend" (collect_ranges is_incb_extend);

  close_out oc
