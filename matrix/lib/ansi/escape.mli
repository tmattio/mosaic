(** ANSI escape sequence builders.

    Low-level backend for {!Ansi}. Sequences are functions ([writer -> unit])
    that append directly to a pre-allocated buffer with zero intermediate
    allocation. Re-exported by {!Ansi} which adds high-level convenience. *)

(** {1 The Writer} *)

type writer = Writer.t
(** An abstract buffer writer.

    It wraps a [Bytes.t] buffer and manages a write position. It is mutable and
    not thread-safe. *)

val make : bytes -> writer
(** [make buf] creates a writer targeting [buf].

    {b Precondition}: [buf] must be large enough to contain the generated
    sequences. Operations raise [Invalid_argument] if the buffer capacity is
    exceeded. *)

val len : writer -> int
(** [len w] returns the number of bytes currently written to [w]. *)

val reset_pos : writer -> unit
(** [reset_pos w] resets the write position to zero.

    Allows reusing a writer without allocation. The underlying buffer is not
    modified; subsequent writes simply overwrite previous content. *)

val slice : writer -> bytes
(** [slice w] returns a fresh copy of the written data.

    Equivalent to [Bytes.sub buf 0 (len w)]. *)

(** {1 Sequence Combinators} *)

type t = writer -> unit
(** A sequence builder function. *)

val empty : t
(** [empty] is the identity sequence. It emits nothing. *)

val literal : string -> t
(** [literal s] emits the string [s] verbatim. *)

val char : char -> t
(** [char c] emits the character [c]. *)

val concat : t -> t -> t
(** [concat a b] emits sequence [a] followed by [b]. *)

val seq : t list -> t
(** [seq xs] emits the list of sequences [xs] in order. *)

val bytes : bytes -> off:int -> len:int -> t
(** [bytes b ~off ~len] writes a slice of bytes directly to the output.

    {b Zero-allocation}: Copies data immediately into the writer's buffer.

    Raises [Invalid_argument] if the slice is out of bounds. *)

val utf8 : int -> t
(** [utf8 codepoint] encodes a Unicode scalar value into UTF-8 and writes it.

    Handles 1-4 byte sequences. Invalid codepoints (negative, > 0x10FFFF, or
    surrogates in the range 0xD800-0xDFFF) are replaced with U+FFFD. *)

val emit : t -> writer -> unit
(** [emit seq w] applies the sequence [seq] to the writer [w]. *)

val to_string : t -> string
(** [to_string seq] converts the sequence to a string.

    Allocates a temporary buffer. Use [emit] for high-performance scenarios. *)

val to_buffer : t -> Buffer.t -> unit
(** [to_buffer seq buf] appends the sequence to an existing [Buffer.t].

    Convenience wrapper that allocates an intermediate string via {!to_string}.
    For high-performance scenarios, prefer {!emit} with a pre-allocated buffer.
*)

(** {1 Primitives} *)

val esc : string -> t
(** [esc body] emits a CSI sequence [ESC \[ body].

    Example: [esc "2J"] becomes ["\027\[2J"]. *)

val csi : params:string -> command:char -> t
(** [csi ~params ~command] emits [ESC \[ params command]. *)

val sgr : int list -> t
(** [sgr codes] emits an SGR sequence [ESC \[ codes m].

    Example: [sgr [1; 31]] becomes ["\027\[1;31m"].

    Note: [sgr []] emits nothing. Use [reset] or [sgr [0]] to clear attributes.
*)

val sgr_direct : ((int -> unit) -> unit) -> writer -> unit
(** [sgr_direct f w] emits SGR codes generated by callback [f].

    {b Optimization}: Avoids list allocation for dynamic styles. The callback
    [f] receives a [push] function; every call to [push code] appends that
    integer to the sequence parameter list. *)

(** {2 Low-level SGR Building}

    These primitives allow zero-allocation SGR sequence construction by writing
    directly to the buffer. Use when the closure overhead of {!sgr_direct} is
    unacceptable (e.g., in hot render loops).

    {b Usage}:
    {[
      (* Emit: \027[0;38;2;255;0;0m (reset + red foreground) *)
      Escape.sgr_open w;
      Escape.sgr_code w 0;
      Escape.sgr_sep w;
      Escape.sgr_code w 38;
      Escape.sgr_sep w;
      Escape.sgr_code w 2;
      Escape.sgr_sep w;
      Escape.sgr_code w 255;
      Escape.sgr_sep w;
      Escape.sgr_code w 0;
      Escape.sgr_sep w;
      Escape.sgr_code w 0;
      Escape.sgr_close w
    ]} *)

val sgr_open : writer -> unit
(** [sgr_open w] writes the SGR sequence opener [ESC \[]. *)

val sgr_code : writer -> int -> unit
(** [sgr_code w n] writes an integer parameter. *)

val sgr_sep : writer -> unit
(** [sgr_sep w] writes the parameter separator [;]. *)

val sgr_close : writer -> unit
(** [sgr_close w] writes the SGR terminator [m]. *)

val reset : t
(** [reset] emits the SGR reset sequence [ESC \[ 0 m]. *)

(** {1 Cursor Control} *)

(** {2 Relative Movement} *)

val cursor_up : n:int -> t
(** [cursor_up ~n] moves the cursor up [n] lines. Clamps negative values to 0.
*)

val cursor_down : n:int -> t
(** [cursor_down ~n] moves the cursor down [n] lines. *)

val cursor_forward : n:int -> t
(** [cursor_forward ~n] moves the cursor right [n] columns. *)

val cursor_back : n:int -> t
(** [cursor_back ~n] moves the cursor left [n] columns. *)

val cursor_next_line : n:int -> t
(** [cursor_next_line ~n] moves the cursor down [n] lines and to the first
    column (CNL). *)

val cursor_previous_line : n:int -> t
(** [cursor_previous_line ~n] moves the cursor up [n] lines and to the first
    column (CPL). *)

(** {2 Absolute Positioning} *)

val cursor_horizontal_absolute : int -> t
(** [cursor_horizontal_absolute col] moves to 1-based column [col]. Clamps
    values < 1 to 1. *)

val cursor_vertical_absolute : int -> t
(** [cursor_vertical_absolute row] moves to 1-based row [row]. Clamps values < 1
    to 1. *)

val cursor_position : row:int -> col:int -> t
(** [cursor_position ~row ~col] moves to 1-based coordinates [(row, col)]. *)

(** {2 State} *)

val cursor_save : t
(** [cursor_save] saves cursor position (CSI s).

    Uses the ANSI.SYS/SCO sequence, widely supported by modern terminals. Must
    be paired with {!cursor_restore}. *)

val cursor_restore : t
(** [cursor_restore] restores cursor position saved by {!cursor_save} (CSI u).

    Behavior undefined if called without prior {!cursor_save}. *)

(** {2 Appearance} *)

type cursor_shape =
  [ `Default
  | `Blinking_block
  | `Block
  | `Blinking_underline
  | `Underline
  | `Blinking_bar
  | `Bar ]
(** Cursor shape for DECSCUSR. *)

val cursor_style : shape:cursor_shape -> t
(** [cursor_style ~shape] sets the cursor shape (DECSCUSR). *)

val cursor_color : r:int -> g:int -> b:int -> t
(** [cursor_color ~r ~g ~b] sets the cursor color (OSC 12).

    Always pair with either {!reset_cursor_color} (for terminals supporting OSC
    112) or {!reset_cursor_color_fallback} (for compatibility with terminals
    that only support OSC 12) during teardown. *)

val reset_cursor_color : t
(** [reset_cursor_color] resets the cursor color to terminal default (OSC 112).

    Preferred method for terminals supporting OSC 112. *)

val reset_cursor_color_fallback : t
(** [reset_cursor_color_fallback] resets cursor color using OSC 12 "default".

    Fallback for terminals that only support OSC 12. *)

(** {1 Screen Control} *)

val clear : t
(** [clear] clears the visible screen without moving cursor (ED 2).

    Erases entire display but leaves cursor position unchanged. Use
    {!clear_and_home} to also move cursor to home. *)

val home : t
(** [home] moves the cursor to (1, 1). *)

val clear_and_home : t
(** [clear_and_home] moves to home, then clears the screen.

    Moves cursor to (1, 1) then erases entire display. Atomic operation to avoid
    flicker. *)

type erase_display_mode = [ `Below | `Above | `All | `Scrollback ]
(** Erase display mode for ED (Erase in Display). *)

val erase_display : mode:erase_display_mode -> t
(** [erase_display ~mode] erases parts of the screen (ED). *)

val erase_below_cursor : t
(** [erase_below_cursor] clears from the cursor to the end of the screen (ED 0).
*)

type erase_line_mode = [ `Right | `Left | `All ]
(** Erase line mode for EL (Erase in Line). *)

val erase_line : mode:erase_line_mode -> t
(** [erase_line ~mode] erases parts of the current line (EL). *)

val insert_lines : n:int -> t
(** [insert_lines ~n] inserts [n] blank lines at the cursor (IL). *)

val delete_lines : n:int -> t
(** [delete_lines ~n] deletes [n] lines at the cursor (DL). *)

val scroll_up : n:int -> t
(** [scroll_up ~n] scrolls the viewport up by [n] lines (SU). *)

val scroll_down : n:int -> t
(** [scroll_down ~n] scrolls the viewport down by [n] lines (SD). *)

val set_scrolling_region : top:int -> bottom:int -> t
(** [set_scrolling_region ~top ~bottom] restricts scrolling to the specified
    line range.

    {b Invariant}: [top] must be >= 1 and [bottom] > [top].

    Raises [Invalid_argument] if bounds are invalid. *)

val reset_scrolling_region : t
(** [reset_scrolling_region] resets the scrolling region to the full screen
    (DECSTBM reset). Equivalent to emitting [ESC \[ r]. *)

(** {1 Colors and Attributes} *)

val set_foreground : r:int -> g:int -> b:int -> t
(** [set_foreground ~r ~g ~b] sets the foreground color (Truecolor). Clamps
    values to [0-255]. *)

val set_background : r:int -> g:int -> b:int -> t
(** [set_background ~r ~g ~b] sets the background color (Truecolor). *)

val reset_background : t
(** [reset_background] resets the background color to default (SGR 49). *)

val reset_foreground : t
(** [reset_foreground] resets the foreground color to terminal default (SGR 39).
*)

(** {1 Terminal Properties} *)

val set_title : title:string -> t
(** [set_title ~title] sets the window title (OSC 0). *)

val explicit_width : width:int -> text:string -> t
(** [explicit_width ~width ~text] renders [text] while forcing the terminal to
    treat it as occupying [width] cells.

    Emits OSC 66 sequence. The text payload is emitted verbatim (no escaping);
    ensure [text] does not contain unescaped ST sequences (ESC \\) which would
    terminate the OSC prematurely. *)

val explicit_width_bytes : width:int -> bytes:bytes -> off:int -> len:int -> t
(** [explicit_width_bytes ~width ~bytes ~off ~len] writes directly from a byte
    buffer without creating intermediate strings.

    Same sanitization requirements apply: ensure the byte slice does not contain
    unescaped ST sequences. *)

(** {1 Operating System Commands (OSC)} *)

type terminator = [ `Bel | `St ]
(** OSC terminator type. *)

val osc : ?terminator:terminator -> payload:string -> t
(** [osc ?terminator ~payload] emits an OSC sequence. *)

(** {2 Hyperlinks (OSC 8)} *)

val hyperlink_start : ?params:string -> url:string -> t
(** [hyperlink_start ?params ~url] opens a hyperlink.

    Must be paired with {!hyperlink_end}.

    @param params
      Optional key=value pairs (e.g., "id=link1") for terminal link
      identification. Defaults to empty string. *)

val hyperlink_end : t
(** [hyperlink_end] closes the current hyperlink.

    Must be paired with {!hyperlink_start}. *)

val hyperlink : ?params:string -> url:string -> text:string -> t
(** [hyperlink ...] emits a complete linked text segment. *)

(** {2 Direct Hyperlink Emission}

    Zero-allocation versions for use in hot render loops. *)

val hyperlink_open : writer -> string -> unit
(** [hyperlink_open w url] opens a hyperlink directly without allocation.

    Equivalent to [emit (hyperlink_start ~url) w] but avoids closure creation.
*)

val hyperlink_close : writer -> unit
(** [hyperlink_close w] closes the current hyperlink directly. *)

(** {1 Terminal Modes} *)

type mode =
  | Cursor_visible  (** DECTCEM 25 — cursor visibility. *)
  | Mouse_tracking  (** DECSET 1000 — basic mouse click reporting. *)
  | Mouse_button_tracking  (** DECSET 1002 — button-event tracking. *)
  | Mouse_motion  (** DECSET 1003 — any-event (all motion) tracking. *)
  | Mouse_sgr  (** DECSET 1006 — SGR extended coordinates. *)
  | Mouse_sgr_pixel  (** DECSET 1016 — SGR pixel coordinates (Kitty). *)
  | Mouse_x10  (** DECSET 9 — legacy X10 mouse protocol. *)
  | Urxvt_mouse  (** DECSET 1015 — urxvt extended coordinates. *)
  | Alternate_screen  (** DECSET 1049 — alternate screen buffer. *)
  | Focus_tracking  (** DECSET 1004 — focus in/out reporting. *)
  | Bracketed_paste  (** DECSET 2004 — paste boundary markers. *)
  | Sync_output  (** DECSET 2026 — synchronized output. *)
  | Unicode  (** DECSET 2027 — Unicode mode. *)
  | Color_scheme  (** DECSET 2031 — color scheme reporting. *)
(** Terminal private modes. Each variant corresponds to a DEC private mode
    that can be toggled via {!enable}/{!disable}. *)

val enable : mode -> t
(** [enable mode] emits the DECSET sequence to activate [mode].

    Example:
    {[
      let setup =
        Escape.seq
          (List.map Escape.enable
             [ Mouse_sgr; Mouse_motion; Focus_tracking; Bracketed_paste ])
    ]} *)

val disable : mode -> t
(** [disable mode] emits the DECRST sequence to deactivate [mode]. *)

(** {2 Keyboard Encoding} *)

val csi_u_on : t
(** [csi_u_on] enables CSI-u extended keyboard encoding. *)

val csi_u_off : t
(** [csi_u_off] disables CSI-u encoding. *)

val csi_u_push : flags:int -> t
(** [csi_u_push ~flags] pushes Kitty keyboard protocol flags. *)

val csi_u_pop : t
(** [csi_u_pop] pops the Kitty keyboard protocol state. *)

val modify_other_keys_on : t
(** [modify_other_keys_on] enables Xterm modifyOtherKeys (level 1). *)

val modify_other_keys_off : t
(** [modify_other_keys_off] disables modifyOtherKeys. *)

(** {1 Device and Capability Queries} *)

type query =
  | Cursor_position  (** DSR 6 — current cursor position. *)
  | Pixel_size  (** CSI 14 t — terminal pixel dimensions. *)
  | Device_attributes  (** DA1 — primary device attributes. *)
  | Tertiary_attributes  (** DA3 — tertiary device attributes. *)
  | Terminal_identity  (** XTVERSION — terminal name and version. *)
  | Device_status  (** DSR 5 — generic status report. *)
  | Csi_u_support  (** CSI ? u — CSI-u keyboard encoding support. *)
  | Kitty_graphics  (** Kitty graphics protocol probe. *)
  | Sixel_geometry  (** Sixel graphics geometry limits. *)
  | Explicit_width_support  (** OSC 66 — explicit width probe. *)
  | Scaled_text_support  (** OSC 66 — scaled text probe. *)
  | Color_scheme_query  (** DSR 996 — terminal color scheme. *)
  | Focus_mode  (** DECRQM 1004 — focus tracking state. *)
  | Sgr_pixels_mode  (** DECRQM 1016 — SGR pixel mouse state. *)
  | Bracketed_paste_mode  (** DECRQM 2004 — bracketed paste state. *)
  | Sync_mode  (** DECRQM 2026 — synchronized output state. *)
  | Unicode_mode  (** DECRQM 2027 — Unicode mode state. *)
  | Color_scheme_mode  (** DECRQM 2031 — color scheme reporting state. *)
(** Terminal capability and state queries. Each variant emits the appropriate
    query sequence; the terminal responds asynchronously. Parse responses via
    {!Parser} or raw input handling. *)

val query : query -> t
(** [query q] emits the query sequence for [q]. *)
