(** Terminal input events: keys, modifiers, mouse, capabilities and high-level
    events.

    The types here mirror {!Input.t} and its supporting records. They live in a
    separate module so components that only need the data model (e.g., the
    terminal runtime) can depend on them without pulling in the parser
    implementation. *)

(** {1 Keys and modifiers} *)

module Key : sig
  (** Physical/logical keyboard keys.

      Most keys map to dedicated constructors. The [Char] variant handles all
      Unicode characters including control codes. Keypad keys ([KP_*]) are
      reported when the terminal sends distinct codes for keypad vs main
      keyboard keys. The [Unknown] variant captures unrecognized Kitty protocol
      key codes for forward compatibility. *)
  type t =
    | Char of Uchar.t
        (** Unicode character. Includes control characters (e.g.,
            [Uchar.of_int 0x03] for Ctrl+C) *)
    | Enter
    | Line_feed
    | Tab
    | Backspace
    | Delete
    | Escape
    | Up
    | Down
    | Left
    | Right
    | Home
    | End
    | Page_up
    | Page_down
    | Insert
    | F of int
        (** Function keys. Values outside 1-35 may appear from Kitty protocol
            but are represented as-is without validation. *)
    | Print_screen
    | Pause
    | Menu
    | Scroll_lock
    | Media_play
    | Media_pause
    | Media_play_pause
    | Media_stop
    | Media_reverse
    | Media_fast_forward
    | Media_rewind
    | Media_next
    | Media_prev
    | Media_record
    | Volume_up
    | Volume_down
    | Volume_mute
    | Shift_left
    | Shift_right
    | Ctrl_left
    | Ctrl_right
    | Alt_left
    | Alt_right
    | Super_left
    | Super_right
    | Hyper_left
    | Hyper_right
    | Meta_left
    | Meta_right
    | Iso_level3_shift
    | Iso_level5_shift
    | Caps_lock
    | Num_lock
    | KP_0
        (** Keypad keys ([KP_*]) reported when terminals send distinct codes. *)
    | KP_1
    | KP_2
    | KP_3
    | KP_4
    | KP_5
    | KP_6
    | KP_7
    | KP_8
    | KP_9
    | KP_decimal
    | KP_divide
    | KP_multiply
    | KP_subtract
    | KP_add
    | KP_enter
    | KP_equal
    | KP_separator
    | KP_begin
    | KP_left
    | KP_right
    | KP_up
    | KP_down
    | KP_page_up
    | KP_page_down
    | KP_home
    | KP_end
    | KP_insert
    | KP_delete
    | Unknown of int
        (** Unknown key code from Private Use Area (PUA) or unmapped sequences.
            The [int] value is the Kitty protocol key code. *)

  val equal : t -> t -> bool
  (** [equal a b] tests structural equality on keys.

      For [Char] variants, compares [Uchar.t] values by their code point.
      Unicode normalization is not performed; [U+00E9] (Ã©) and [U+0065 U+0301]
      (e + combining acute) are considered distinct. *)

  val pp : Format.formatter -> t -> unit
  (** [pp fmt k] prints [k] for debugging and logs. *)

  (** [event_type] indicates the type of key event.

      Only available when the terminal supports advanced keyboard protocols
      (Kitty protocol). Legacy terminals always report [Press] events. The
      [Repeat] event is generated by the terminal when a key is held down. The
      [Release] event tracks when keys are released, useful for implementing
      key-up handlers. *)
  type event_type = Press | Repeat | Release

  type modifier = {
    ctrl : bool;  (** Control key held *)
    alt : bool;  (** Alt/Option key held *)
    shift : bool;  (** Shift key held *)
    super : bool;  (** Super/Windows/Command key held *)
    hyper : bool;  (** Hyper modifier key held (rare) *)
    meta : bool;  (** Meta modifier key held *)
    caps_lock : bool;  (** Caps lock is active *)
    num_lock : bool;  (** Num lock is active *)
  }
  (** Modifier state. Lock fields indicate toggle state, not whether the key is
      currently pressed. *)

  val no_modifier : modifier
  (** [no_modifier] represents no modifiers pressed or active. Use as a base
      value: [ { no_modifier with ctrl = true } ]. *)

  val equal_modifier : modifier -> modifier -> bool
  (** [equal_modifier a b] tests structural equality on modifiers. *)

  val pp_modifier : Format.formatter -> modifier -> unit
  (** [pp_modifier fmt m] prints modifier sets. *)

  type event = {
    key : t;  (** The key that was pressed. *)
    modifier : modifier;  (** Active modifiers. *)
    event_type : event_type;  (** Type of key event. *)
    associated_text : string;
        (** UTF-8 encoded text to insert. Populated for Kitty protocol events
            (as provided by terminal) and legacy text bytes (as decoded by
            parser). Empty for non-text keys or sequences where text wasn't
            provided. *)
    shifted_key : Uchar.t option;
        (** Key representation with shift applied (Kitty protocol). [None] for
            legacy terminals. *)
    base_key : Uchar.t option;
        (** Key representation without modifiers (Kitty protocol). [None] for
            legacy terminals. *)
  }
  (** Combines a key press with modifiers and extra metadata. [event_type] only
      varies on terminals implementing the Kitty protocol; legacy terminals
      always report [Press]. *)

  val make :
    ?modifier:modifier ->
    ?event_type:event_type ->
    ?associated_text:string ->
    ?shifted_key:Uchar.t ->
    ?base_key:Uchar.t ->
    t ->
    event
  (** [make ?modifier ?event_type ?associated_text ?shifted_key ?base_key key]
      constructs a key event for pattern matching.

      Set [associated_text] when downstream logic should treat the key as
      textual input. Kitty protocol populates this automatically for
      text-producing keys. *)

  val of_char :
    ?modifier:modifier ->
    ?event_type:event_type ->
    ?associated_text:string ->
    ?shifted_key:Uchar.t ->
    ?base_key:Uchar.t ->
    char ->
    event
  (** [of_char ?modifier ?event_type ?associated_text ?shifted_key ?base_key c]
      constructs a key event from an ASCII character.

      Convenience wrapper around {!make} that converts the [char] to [Uchar.t]
      before creating [Char k]. The resulting event automatically sets
      [associated_text] to a shared single-character string. Uses shared strings
      for ASCII characters to reduce allocations. *)

  val equal_event : event -> event -> bool
  (** [equal_event a b] tests structural equality on key events. *)

  val pp_event : Format.formatter -> event -> unit
  (** [pp_event fmt e] prints key events. *)

  (** Small helpers, kept here to avoid extra modules. *)

  val is_char : t -> bool
  (** [is_char k] returns [true] when [k] is [Char _]. *)

  val is_enter : t -> bool
  (** [is_enter k] returns [true] when [k] is [Enter]. *)

  val is_arrow : t -> bool
  (** [is_arrow k] returns [true] when [k] is an arrow key. *)

  val is_function : t -> bool
  (** [is_function k] returns [true] for [F _] keys. *)

  val is_ctrl_char : t -> bool
  (** [is_ctrl_char k] detects ASCII control characters. *)

  val ctrl : modifier -> bool
  (** [ctrl m] checks if Control is active in [m]. *)

  val alt : modifier -> bool
  (** [alt m] checks if Alt/Option is active in [m]. *)

  val shift : modifier -> bool
  (** [shift m] checks if Shift is active in [m]. *)
end

(** {1 Mouse} *)

module Mouse : sig
  (** Mouse buttons and motion events. *)
  type button =
    | Left
    | Middle
    | Right
    | Wheel_up
    | Wheel_down
    | Wheel_left
    | Wheel_right
    | Button of int
        (** Extended buttons (4+). In legacy basic tracking modes (X10/Normal
            and URXVT), release events do not encode which button was released;
            these are reported as [Button 0] so downstream code can treat them
            as a generic release. *)

  val equal_button : button -> button -> bool
  (** [equal_button a b] tests structural equality on mouse buttons. *)

  val pp_button : Format.formatter -> button -> unit
  (** [pp_button fmt b] prints mouse buttons. *)

  type button_state = { left : bool; middle : bool; right : bool }
  (** Tracks which primary buttons are held during motion events. *)

  val equal_button_state : button_state -> button_state -> bool
  (** [equal_button_state a b] tests structural equality on button states. *)

  val pp_button_state : Format.formatter -> button_state -> unit
  (** [pp_button_state fmt s] prints button states. *)

  type scroll_direction =
    | Scroll_up
    | Scroll_down
    | Scroll_left
    | Scroll_right  (** Normalized scroll direction for wheel events. *)

  val equal_scroll_direction : scroll_direction -> scroll_direction -> bool
  (** [equal_scroll_direction a b] tests structural equality on scroll
      directions. *)

  val pp_scroll_direction : Format.formatter -> scroll_direction -> unit
  (** [pp_scroll_direction fmt d] prints scroll directions. *)

  type event =
    | Button_press of int * int * button * Key.modifier
        (** Button pressed at [(x, y)] with modifiers. Coordinates are 0-based,
            top-left origin. *)
    | Button_release of int * int * button * Key.modifier
        (** Button released at [(x, y)] with modifiers. In legacy basic tracking
            modes (X10/Normal and URXVT), the released button is reported as
            [Button 0] because the terminal does not encode it. *)
    | Motion of int * int * button_state * Key.modifier
        (** Mouse moved to [(x, y)] with button states and modifiers. *)

  val equal_event : event -> event -> bool
  (** [equal_event a b] tests structural equality on mouse events. *)

  val pp_event : Format.formatter -> event -> unit
  (** [pp_event fmt e] prints mouse events. *)
end

(** {1 Capability / terminal reports} *)

module Caps : sig
  type mode_report = { is_private : bool; modes : (int * int) list }
  (** Status response for DEC private modes (DECRPM). [modes] holds
      [(mode, value)] pairs following the DEC convention: 0/3 for disabled, 1/2
      for enabled. *)

  val equal_mode_report : mode_report -> mode_report -> bool
  (** [equal_mode_report a b] tests structural equality on mode reports. *)

  val pp_mode_report : Format.formatter -> mode_report -> unit
  (** [pp_mode_report fmt r] prints mode reports. *)

  (** Terminal capability responses. *)
  type event =
    | Device_attributes of int list
        (** Device Attributes (DA/DA2/DA3) response payload. *)
    | Mode_report of mode_report  (** DEC mode status report (DECRPM). *)
    | Pixel_resolution of int * int
        (** Terminal pixel dimensions [(width_px, height_px)] reported by
            [CSI 4 ; height ; width t]. *)
    | Cursor_position of int * int
        (** Cursor position report: [(row, col)] with 1-based coordinates. Row 1
            is the top line, column 1 is the leftmost column. *)
    | Xtversion of string
        (** XTerm [XTVERSION] response payload (DCS > | ... ST). *)
    | Kitty_graphics_reply of string
        (** Kitty graphics response (APC G ... ST) payload. *)
    | Kitty_keyboard of { level : int; flags : int option }
        (** Kitty keyboard protocol query response: [CSI ? level [; flags] u].
            [level] is non-zero when the protocol is supported. [flags] carries
            the optional terminal-reported bitfield when present. *)
    | Color_scheme of [ `Dark | `Light | `Unknown of int ]
        (** Color scheme DSR response: [CSI ? 997 ; value n]. Indicates the
            terminal's current color scheme preference. Value 1 = dark mode,
            value 2 = light mode. This is the response to [CSI ? 996 n] query. *)

  val equal_event : event -> event -> bool
  (** [equal_event a b] tests structural equality on capability events. *)

  val pp_event : Format.formatter -> event -> unit
  (** [pp_event fmt e] prints capability events. *)
end

(** {1 Unified high-level event} *)

(** Represents any input or capability event from the terminal. *)
type t =
  | Key of Key.event  (** Keyboard input with modifiers. *)
  | Mouse of Mouse.event  (** Mouse button or motion. *)
  | Scroll of int * int * Mouse.scroll_direction * int * Key.modifier
      (** Mouse wheel scroll at [(x, y)] with direction and delta.

          [Scroll (x, y, dir, delta, mods)] normalizes wheel actions across
          terminals (SGR/URXVT/X10) into a single event with:
          - [x], [y]: 0-based coordinates
          - [dir]: scroll direction
          - [delta]: scroll step (usually 1)
          - [mods]: modifiers (shift/alt/ctrl)

          This replaces [Wheel_*] button press/release at the high level. *)
  | Resize of int * int  (** Terminal resized to [(width, height)]. *)
  | Focus  (** Terminal window gained focus. *)
  | Blur  (** Terminal window lost focus. *)
  | Paste of string
      (** Pasted content after stripping ANSI escape sequences. Requires
          bracketed paste mode. Empty payloads are dropped. *)
  | Clipboard of string * string
      (** OSC 52 clipboard response: [(selection, data)]. The data is
          base64-decoded when possible and otherwise returned verbatim. *)
  | Osc of int * string
      (** Other OSC sequences: (number, payload). Payload is raw text between
          the OSC introducer and terminator with no additional sanitization. *)

val equal : t -> t -> bool
(** [equal e1 e2] compares events for semantic equality.

    For [Key] events, only the [key] and [modifier] fields are compared (to
    match the historical {!Input.t_equal}). All other variants compare their
    fields structurally. *)

val equal_full : t -> t -> bool
(** [equal_full e1 e2] compares events for full structural equality.

    Unlike {!equal}, this compares all fields of [Key] events including
    [event_type], [associated_text], [shifted_key], and [base_key]. Use this
    when you need to distinguish between press/repeat/release events or when the
    full event context matters. *)

val pp : Format.formatter -> t -> unit
(** [pp fmt e] prints a high-level event. *)

(** {1 Convenience constructors} *)

val key :
  ?modifier:Key.modifier ->
  ?event_type:Key.event_type ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  Key.t ->
  t
(** [key ?modifier ?event_type ?associated_text ?shifted_key ?base_key k]
    constructs a {!Key} event. *)

val char :
  ?modifier:Key.modifier ->
  ?event_type:Key.event_type ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  char ->
  t
(** [char ?modifier ?event_type ?associated_text ?shifted_key ?base_key c]
    constructs a {!Key} event for ASCII character [c]. Convenience wrapper
    around {!key} that converts the [char] to [Uchar.t] and sets
    [associated_text]. *)

val key_event :
  ?modifier:Key.modifier ->
  ?event_type:Key.event_type ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  Key.t ->
  Key.event
(** [key_event] is a toplevel alias to {!Key.make}, useful when you need the raw
    {!Key.event} without wrapping it into {!t}. *)

val char_event :
  ?modifier:Key.modifier ->
  ?event_type:Key.event_type ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  char ->
  Key.event
(** [char_event] mirrors {!Key.of_char} and returns a {!Key.event} directly. *)

val press :
  ?modifier:Key.modifier ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  Key.t ->
  Key.event
(** [press key] builds a {!Key.event} with [event_type = Press]. *)

val repeat :
  ?modifier:Key.modifier ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  Key.t ->
  Key.event
(** [repeat key] builds a {!Key.event} with [event_type = Repeat]. *)

val release :
  ?modifier:Key.modifier ->
  ?associated_text:string ->
  ?shifted_key:Uchar.t ->
  ?base_key:Uchar.t ->
  Key.t ->
  Key.event
(** [release key] builds a {!Key.event} with [event_type = Release]. *)

val mouse_press : ?modifier:Key.modifier -> int -> int -> Mouse.button -> t
(** [mouse_press ?modifier x y button] creates a mouse button press event. *)

val mouse_release : ?modifier:Key.modifier -> int -> int -> Mouse.button -> t
(** [mouse_release ?modifier x y button] creates a mouse button release event.
*)

val mouse_motion :
  ?modifier:Key.modifier -> int -> int -> Mouse.button_state -> t
(** [mouse_motion ?modifier x y state] creates a mouse motion event. *)

(** {1 Helpers that depend on [t]} *)

val match_ctrl_char : t -> char option
(** [match_ctrl_char e] extracts the ASCII character from [Ctrl+<key>]
    combinations.

    Returns [Some c] when [e] is [Key { key = Char u; modifier.ctrl = true; _}]
    and [u] is an ASCII code (<0x80). Returns [None] otherwise. *)

val is_scroll : t -> bool
(** [is_scroll e] returns [true] for normalized [Scroll] events or wheel
    press/release sequences. *)

val is_drag : t -> bool
(** [is_drag e] returns [true] when [e] is a mouse motion event with any button
    pressed. *)
