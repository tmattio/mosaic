(* Helper functions for initialising GridTrack's from styles This mainly
   consists of evaluating GridAutoTracks *)

open Geometry
open Style
open Style.Grid

(* The auto-repeat fit strategy to use *)
type auto_repeat_strategy =
  | Max_repetitions_that_do_not_overflow
      (** If the grid container has a definite size or max size in the relevant
          axis:
          - then the number of repetitions is the largest possible positive
            integer that does not cause the grid to overflow the content box of
            its grid container. *)
  | Min_repetitions_that_do_overflow
      (** Otherwise, if the grid container has a definite min size in the
          relevant axis:
          - then the number of repetitions is the smallest possible positive
            integer that fulfills that minimum requirement *)

(* Helper function to compute the definite value of a track *)
let track_definite_value sizing_function parent_size =
  let max_size =
    Track_sizing_function.Max.definite_value sizing_function parent_size
  in
  let min_size =
    Track_sizing_function.Min.definite_value sizing_function parent_size
  in
  match (max_size, min_size) with
  | Some max_val, Some min_val -> Some (max max_val min_val)
  | Some max_val, None -> Some max_val
  | None, Some min_val -> Some min_val
  | None, None -> None

(* Compute the number of rows and columns in the explicit grid *)
let compute_explicit_grid_size_in_axis ~style ~auto_fit_container_size
    ~auto_fit_strategy ~resolve_calc_value ~axis =
  let template =
    match axis with
    | Absolute_axis.Horizontal -> Style.grid_template_columns style
    | Absolute_axis.Vertical -> Style.grid_template_rows style
  in
  (* If template contains no tracks, then there are trivially zero explicit
     tracks *)
  let track_count = List.length template in
  if track_count = 0 then (0, 0)
  else
    (* If there are any repetitions that contains no tracks, then the whole
       definition should be considered invalid and we default to no explicit
       tracks *)
    let template_has_repetitions_with_zero_tracks =
      List.exists
        (function
          | Template_component.Single _ -> false
          | Template_component.Repeat rep -> Repetition.track_count rep = 0)
        template
    in
    if template_has_repetitions_with_zero_tracks then (0, 0)
    else
      (* Compute that number of track generated by single track definition and
         repetitions with a fixed repetition count *)
      let non_auto_repeating_track_count =
        List.fold_left
          (fun acc track_def ->
            match track_def with
            | Template_component.Single _ -> acc + 1
            | Template_component.Repeat rep -> (
                match Repetition.count rep with
                | Repetition_count.Count count ->
                    acc + (count * Repetition.track_count rep)
                | Repetition_count.Auto_fit | Repetition_count.Auto_fill -> acc))
          0 template
      in

      let auto_repetition_count =
        List.fold_left
          (fun acc track_def ->
            match track_def with
            | Template_component.Repeat rep -> (
                match Repetition.count rep with
                | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                    acc + 1
                | _ -> acc)
            | _ -> acc)
          0 template
      in

      let all_track_defs_have_fixed_component =
        List.for_all
          (function
            | Template_component.Single sizing_function ->
                Track_sizing_function.has_fixed_component sizing_function
            | Template_component.Repeat rep ->
                List.for_all Track_sizing_function.has_fixed_component
                  (Repetition.tracks rep))
          template
      in

      let template_is_valid =
        auto_repetition_count = 0
        || (auto_repetition_count = 1 && all_track_defs_have_fixed_component)
      in

      (* If the template is invalid because it contains multiple auto-repetition
         definitions or it combines an auto-repetition definition with
         non-fixed-size track sizing functions, then disregard it entirely and
         default to zero explicit tracks *)
      if not template_is_valid then (0, 0)
      else if auto_repetition_count = 0 then
        (* If there are no repetitions, then the number of explicit tracks is
           simply equal to the lengths of the track definition vector (as each
           item in the Vec represents one track). *)
        (0, non_auto_repeating_track_count)
      else
        (* Find the auto-repeat definition *)
        let repetition_definition =
          List.find_map
            (function
              | Template_component.Single _ -> None
              | Template_component.Repeat rep -> (
                  match Repetition.count rep with
                  | Repetition_count.Count _ -> None
                  | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                      Some rep))
            template
          |> Option.get
        in
        let repetition_tracks = Repetition.tracks repetition_definition in
        let repetition_track_count = List.length repetition_tracks in

        (* Determine the number of repetitions *)
        let num_repetitions =
          match auto_fit_container_size with
          | None -> 1
          | Some inner_container_size -> (
              let parent_size = Some inner_container_size in

              let non_repeating_track_used_space =
                List.fold_left
                  (fun acc track_def ->
                    match track_def with
                    | Template_component.Single sizing_function ->
                        let value =
                          track_definite_value sizing_function parent_size
                        in
                        acc +. Option.value value ~default:0.0
                    | Template_component.Repeat rep -> (
                        match Repetition.count rep with
                        | Repetition_count.Count count ->
                            let sum =
                              List.fold_left
                                (fun acc sizing_function ->
                                  let value =
                                    track_definite_value sizing_function
                                      parent_size
                                  in
                                  acc +. Option.value value ~default:0.0)
                                0.0 (Repetition.tracks rep)
                            in
                            acc +. (sum *. float_of_int count)
                        | Repetition_count.Auto_fit | Repetition_count.Auto_fill
                          ->
                            acc))
                  0.0 template
              in

              let gap_size =
                let gap = Style.gap style in
                Size.get_absolute axis gap |> fun lp ->
                Length_percentage.resolve_or_zero lp parent_size
                  resolve_calc_value
              in

              (* Compute the amount of space that a single repetition of the
                 repeated track list takes *)
              let per_repetition_track_used_space =
                List.fold_left
                  (fun acc sizing_function ->
                    let value =
                      track_definite_value sizing_function parent_size
                    in
                    acc +. Option.value value ~default:0.0)
                  0.0 repetition_tracks
              in

              (* We special case the first repetition here because the number of
                 gaps in the first repetition depends on the number of
                 non-repeating tracks in the template *)
              let first_repetition_and_non_repeating_tracks_used_space =
                non_repeating_track_used_space
                +. per_repetition_track_used_space
                +. float_of_int
                     (max 0
                        (non_auto_repeating_track_count + repetition_track_count
                       - 1))
                   *. gap_size
              in

              (* If a single repetition already overflows the container then we
                 return 1 as the repetition count (the number of repetitions is
                 floored at 1) *)
              if
                first_repetition_and_non_repeating_tracks_used_space
                > inner_container_size
              then 1
              else
                let per_repetition_gap_used_space =
                  float_of_int repetition_track_count *. gap_size
                in
                let per_repetition_used_space =
                  per_repetition_track_used_space
                  +. per_repetition_gap_used_space
                in
                let num_repetition_that_fit =
                  (inner_container_size
                 -. first_repetition_and_non_repeating_tracks_used_space)
                  /. per_repetition_used_space
                in

                (* If the container size is a preferred or maximum size: Then we
                   return the maximum number of repetitions that fit into the
                   container without overflowing. If the container size is a
                   minimum size: - Then we return the minimum number of
                   repetitions required to overflow the size.

                   In all cases we add the additional repetition that was
                   already accounted for in the special-case computation
                   above *)
                match auto_fit_strategy with
                | Max_repetitions_that_do_not_overflow ->
                    int_of_float (floor num_repetition_that_fit) + 1
                | Min_repetitions_that_do_overflow ->
                    int_of_float (ceil num_repetition_that_fit) + 1)
        in

        let grid_template_track_count =
          non_auto_repeating_track_count
          + (repetition_track_count * num_repetitions)
        in
        (num_repetitions, grid_template_track_count)

(* Utility function for repeating logic of creating implicit tracks *)
let create_implicit_tracks tracks count
    (auto_tracks : Track_sizing_function.t array)
    (gap : Style.length_percentage) =
  let auto_len = Array.length auto_tracks in
  if auto_len = 0 then invalid_arg "create_implicit_tracks: empty auto_tracks";
  for i = 0 to count - 1 do
    let track_def = auto_tracks.(i mod auto_len) in
    let track =
      Track_sizing_function.make
        ~min:(Track_sizing_function.min_sizing_function track_def)
        ~max:(Track_sizing_function.max_sizing_function track_def)
      |> Grid_track.create
    in
    tracks := !tracks @ [ track ];
    tracks := !tracks @ [ Grid_track.gutter gap ]
  done

(* Resolve the track sizing functions of explicit tracks, automatically created
   tracks, and gutters given a set of track counts and all of the relevant
   styles *)
let initialize_grid_tracks ~tracks ~counts ~style ~axis ~track_has_items =
  (* Extract styles *)
  let track_template, auto_tracks, gap =
    match axis with
    | Absolute_axis.Horizontal ->
        ( Style.grid_template_columns style,
          Style.grid_auto_columns style,
          (Style.gap style).width )
    | Absolute_axis.Vertical ->
        ( Style.grid_template_rows style,
          Style.grid_auto_rows style,
          (Style.gap style).height )
  in

  (* Clear vector (in case this is a re-layout), reserve space for all tracks
     ahead of time to reduce allocations, and push the initial gutter *)
  tracks := [];
  (* Reserve is not directly available in OCaml, but we can pre-allocate if
     needed *)
  let initial_gutter = Grid_track.gutter gap in
  tracks := [ initial_gutter ];

  let auto_track_count = List.length auto_tracks in

  (* Create negative implicit tracks *)
  if Grid_track_counts.negative_implicit counts > 0 then (
    if auto_track_count = 0 then
      create_implicit_tracks tracks
        (Grid_track_counts.negative_implicit counts)
        (Array.make
           (Grid_track_counts.negative_implicit counts)
           Track_sizing_function.auto)
        gap
    else
      let total = Grid_track_counts.negative_implicit counts in
      let offset = auto_track_count - (total mod auto_track_count) in
      let auto_array = Array.of_list auto_tracks in
      let filled = Array.make total Track_sizing_function.auto in
      for i = 0 to total - 1 do
        let src = (offset + i) mod auto_track_count in
        filled.(i) <- auto_array.(src)
      done;
      create_implicit_tracks tracks total filled gap);

  let current_track_index = ref (Grid_track_counts.negative_implicit counts) in

  (* Create explicit tracks *)
  (* An explicit check against the count (rather than just relying on track_template being empty) is required here
     because a count of zero can result from the track_template being invalid, in which case it should be ignored. *)
  if Grid_track_counts.explicit counts > 0 then
    if track_template <> [] then
      List.iter
        (function
          | Template_component.Single sizing_function ->
              let track =
                Track_sizing_function.make
                  ~min:
                    (Track_sizing_function.min_sizing_function sizing_function)
                  ~max:
                    (Track_sizing_function.max_sizing_function sizing_function)
                |> Grid_track.create
              in
              tracks := !tracks @ [ track ];
              tracks := !tracks @ [ Grid_track.gutter gap ];
              incr current_track_index
          | Template_component.Repeat rep -> (
              match Repetition.count rep with
              | Repetition_count.Count count ->
                  let track_list = Repetition.tracks rep in
                  let track_array = Array.of_list track_list in
                  let track_len = Array.length track_array in
                  let total = Repetition.track_count rep * count in
                  for i = 0 to total - 1 do
                    let sizing_function = track_array.(i mod track_len) in
                    let track =
                      Track_sizing_function.make
                        ~min:
                          (Track_sizing_function.min_sizing_function
                             sizing_function)
                        ~max:
                          (Track_sizing_function.max_sizing_function
                             sizing_function)
                      |> Grid_track.create
                    in
                    tracks := !tracks @ [ track ];
                    tracks := !tracks @ [ Grid_track.gutter gap ];
                    incr current_track_index
                  done
              | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                  let auto_repeated_track_count =
                    Grid_track_counts.explicit counts
                    - (List.length track_template - 1)
                  in
                  let track_list = Repetition.tracks rep in
                  let track_array = Array.of_list track_list in
                  let track_len = Array.length track_array in
                  for i = 0 to auto_repeated_track_count - 1 do
                    let track_def = track_array.(i mod track_len) in
                    let track =
                      Track_sizing_function.make
                        ~min:
                          (Track_sizing_function.min_sizing_function track_def)
                        ~max:
                          (Track_sizing_function.max_sizing_function track_def)
                      |> Grid_track.create
                    in
                    let gutter = Grid_track.gutter gap in
                    let track, gutter =
                      if
                        Repetition.count rep = Repetition_count.Auto_fit
                        && not (track_has_items !current_track_index)
                      then
                        (Grid_track.collapse track, Grid_track.collapse gutter)
                      else (track, gutter)
                    in
                    tracks := !tracks @ [ track ];
                    tracks := !tracks @ [ gutter ];
                    incr current_track_index
                  done))
        track_template;

  let grid_area_tracks =
    Grid_track_counts.negative_implicit counts
    + Grid_track_counts.explicit counts
    - !current_track_index
  in

  (* Create positive implicit tracks *)
  let () =
    let total = Grid_track_counts.positive_implicit counts + grid_area_tracks in
    if total > 0 then (
      if auto_track_count = 0 then
        create_implicit_tracks tracks total
          (Array.make total Track_sizing_function.auto)
          gap
      else
        let auto_array = Array.of_list auto_tracks in
        let auto_len = Array.length auto_array in
        let filled = Array.make total Track_sizing_function.auto in
        for i = 0 to total - 1 do
          filled.(i) <- auto_array.(i mod auto_len)
        done;
        create_implicit_tracks tracks total filled gap)
  in

  (* Mark first and last grid lines as collapsed *)
  match !tracks with
  | [] -> ()
  | first :: rest -> (
      tracks := Grid_track.collapse first :: rest;
      match List.rev !tracks with
      | [] -> ()
      | last :: rest_rev ->
          tracks := List.rev (Grid_track.collapse last :: rest_rev))
