(* Helper functions for initialising GridTrack's from styles
   This mainly consists of evaluating GridAutoTracks *)

open Geometry
open Style
open Style.Grid

(* Helper functions for Seq that might not exist in standard library *)
module Seq_ext = struct
  let rec cycle seq () =
    match seq () with
    | Seq.Nil -> cycle seq ()
    | Seq.Cons (x, xs) -> Seq.Cons (x, fun () -> Seq.append xs (cycle seq) ())

  let repeat x =
    let rec go () = Seq.Cons (x, go) in
    go
end

(* The auto-repeat fit strategy to use *)
type auto_repeat_strategy =
  | Max_repetitions_that_do_not_overflow
      (** If the grid container has a definite size or max size in the relevant
          axis:
          - then the number of repetitions is the largest possible positive
            integer that does not cause the grid to overflow the content box of
            its grid container. *)
  | Min_repetitions_that_do_overflow
      (** Otherwise, if the grid container has a definite min size in the
          relevant axis:
          - then the number of repetitions is the smallest possible positive
            integer that fulfills that minimum requirement *)

(* Helper function to compute the definite value of a track *)
let track_definite_value sizing_function parent_size =
  let max_size =
    Track_sizing_function.Max.definite_value sizing_function parent_size
  in
  let min_size =
    Track_sizing_function.Min.definite_value sizing_function parent_size
  in
  match (max_size, min_size) with
  | Some max_val, Some min_val -> Some (max max_val min_val)
  | Some max_val, None -> Some max_val
  | None, Some min_val -> Some min_val
  | None, None -> None

(* Compute the number of rows and columns in the explicit grid *)
let compute_explicit_grid_size_in_axis ~style ~auto_fit_container_size
    ~auto_fit_strategy ~resolve_calc_value ~axis =
  let template =
    match axis with
    | Absolute_axis.Horizontal -> Style.grid_template_columns style
    | Absolute_axis.Vertical -> Style.grid_template_rows style
  in
  (* If template contains no tracks, then there are trivially zero explicit tracks *)
  let track_count = List.length template in
  if track_count = 0 then (0, 0)
  else
    (* If there are any repetitions that contains no tracks, then the whole definition should be considered invalid
           and we default to no explicit tracks *)
    let template_has_repetitions_with_zero_tracks =
      List.exists
        (function
          | Template_component.Single _ -> false
          | Template_component.Repeat rep -> Repetition.track_count rep = 0)
        template
    in
    if template_has_repetitions_with_zero_tracks then (0, 0)
    else
      (* Compute that number of track generated by single track definition and repetitions with a fixed repetition count *)
      let non_auto_repeating_track_count =
        List.fold_left
          (fun acc track_def ->
            match track_def with
            | Template_component.Single _ -> acc + 1
            | Template_component.Repeat rep -> (
                match Repetition.count rep with
                | Repetition_count.Count count ->
                    acc + (count * Repetition.track_count rep)
                | Repetition_count.Auto_fit | Repetition_count.Auto_fill -> acc))
          0 template
      in

      let auto_repetition_count =
        List.fold_left
          (fun acc track_def ->
            match track_def with
            | Template_component.Repeat rep -> (
                match Repetition.count rep with
                | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                    acc + 1
                | _ -> acc)
            | _ -> acc)
          0 template
      in

      let all_track_defs_have_fixed_component =
        List.for_all
          (function
            | Template_component.Single sizing_function ->
                Track_sizing_function.has_fixed_component sizing_function
            | Template_component.Repeat rep ->
                List.for_all Track_sizing_function.has_fixed_component
                  (Repetition.tracks rep))
          template
      in

      let template_is_valid =
        auto_repetition_count = 0
        || (auto_repetition_count = 1 && all_track_defs_have_fixed_component)
      in

      (* If the template is invalid because it contains multiple auto-repetition definitions or it combines an auto-repetition
             definition with non-fixed-size track sizing functions, then disregard it entirely and default to zero explicit tracks *)
      if not template_is_valid then (0, 0)
      else if auto_repetition_count = 0 then
        (* If there are no repetitions, then the number of explicit tracks is simply equal to the lengths of the track definition
               vector (as each item in the Vec represents one track). *)
        (0, non_auto_repeating_track_count)
      else
        (* Find the auto-repeat definition *)
        let repetition_definition =
          List.find_map
            (function
              | Template_component.Single _ -> None
              | Template_component.Repeat rep -> (
                  match Repetition.count rep with
                  | Repetition_count.Count _ -> None
                  | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                      Some rep))
            template
          |> Option.get
        in
        let repetition_tracks = Repetition.tracks repetition_definition in
        let repetition_track_count = List.length repetition_tracks in

        (* Determine the number of repetitions *)
        let num_repetitions =
          match auto_fit_container_size with
          | None -> 1
          | Some inner_container_size -> (
              let parent_size = Some inner_container_size in

              let non_repeating_track_used_space =
                List.fold_left
                  (fun acc track_def ->
                    match track_def with
                    | Template_component.Single sizing_function ->
                        let value =
                          track_definite_value sizing_function parent_size
                        in
                        acc +. Option.value value ~default:0.0
                    | Template_component.Repeat rep -> (
                        match Repetition.count rep with
                        | Repetition_count.Count count ->
                            let sum =
                              List.fold_left
                                (fun acc sizing_function ->
                                  let value =
                                    track_definite_value sizing_function
                                      parent_size
                                  in
                                  acc +. Option.value value ~default:0.0)
                                0.0 (Repetition.tracks rep)
                            in
                            acc +. (sum *. float_of_int count)
                        | Repetition_count.Auto_fit | Repetition_count.Auto_fill
                          ->
                            acc))
                  0.0 template
              in

              let gap_size =
                let gap = Style.gap style in
                Size.get_absolute gap axis |> fun lp ->
                Length_percentage.resolve_or_zero lp parent_size
                  resolve_calc_value
              in

              (* Compute the amount of space that a single repetition of the repeated track list takes *)
              let per_repetition_track_used_space =
                List.fold_left
                  (fun acc sizing_function ->
                    let value =
                      track_definite_value sizing_function parent_size
                    in
                    acc +. Option.value value ~default:0.0)
                  0.0 repetition_tracks
              in

              (* We special case the first repetition here because the number of gaps in the first repetition
                     depends on the number of non-repeating tracks in the template *)
              let first_repetition_and_non_repeating_tracks_used_space =
                non_repeating_track_used_space
                +. per_repetition_track_used_space
                +. float_of_int
                     (max 0
                        (non_auto_repeating_track_count + repetition_track_count
                       - 1))
                   *. gap_size
              in

              (* If a single repetition already overflows the container then we return 1 as the repetition count
                     (the number of repetitions is floored at 1) *)
              if
                first_repetition_and_non_repeating_tracks_used_space
                > inner_container_size
              then 1
              else
                let per_repetition_gap_used_space =
                  float_of_int repetition_track_count *. gap_size
                in
                let per_repetition_used_space =
                  per_repetition_track_used_space
                  +. per_repetition_gap_used_space
                in
                let num_repetition_that_fit =
                  (inner_container_size
                 -. first_repetition_and_non_repeating_tracks_used_space)
                  /. per_repetition_used_space
                in

                (* If the container size is a preferred or maximum size:
                       Then we return the maximum number of repetitions that fit into the container without overflowing.
                       If the container size is a minimum size:
                       - Then we return the minimum number of repetitions required to overflow the size.
                       
                       In all cases we add the additional repetition that was already accounted for in the special-case computation above *)
                match auto_fit_strategy with
                | Max_repetitions_that_do_not_overflow ->
                    int_of_float (floor num_repetition_that_fit) + 1
                | Min_repetitions_that_do_overflow ->
                    int_of_float (ceil num_repetition_that_fit) + 1)
        in

        let grid_template_track_count =
          non_auto_repeating_track_count
          + (repetition_track_count * num_repetitions)
        in
        (num_repetitions, grid_template_track_count)

(* Utility function for repeating logic of creating implicit tracks *)
let create_implicit_tracks tracks count auto_tracks_iter
    (gap : Style.length_percentage) =
  let rec loop i iter =
    if i < count then
      match iter () with
      | Seq.Nil -> failwith "auto_tracks_iter exhausted unexpectedly"
      | Seq.Cons (track_def, rest) ->
          let track =
            Track_sizing_function.make
              ~min:(Track_sizing_function.min_sizing_function track_def)
              ~max:(Track_sizing_function.max_sizing_function track_def)
            |> Grid_track.create
          in
          tracks := !tracks @ [ track ];
          tracks := !tracks @ [ Grid_track.gutter gap ];
          loop (i + 1) rest
  in
  loop 0 auto_tracks_iter

(* Resolve the track sizing functions of explicit tracks, automatically created tracks, and gutters
   given a set of track counts and all of the relevant styles *)
let initialize_grid_tracks ~tracks ~counts ~style ~axis ~track_has_items =
  (* Extract styles *)
  let track_template, auto_tracks, gap =
    match axis with
    | Absolute_axis.Horizontal ->
        ( Style.grid_template_columns style,
          Style.grid_auto_columns style,
          (Style.gap style).width )
    | Absolute_axis.Vertical ->
        ( Style.grid_template_rows style,
          Style.grid_auto_rows style,
          (Style.gap style).height )
  in

  (* Clear vector (in case this is a re-layout), reserve space for all tracks ahead of time to reduce allocations,
     and push the initial gutter *)
  tracks := [];
  (* Reserve is not directly available in OCaml, but we can pre-allocate if needed *)
  let initial_gutter = Grid_track.gutter gap in
  tracks := [ initial_gutter ];

  let auto_track_count = List.length auto_tracks in

  (* Create negative implicit tracks *)
  if Grid_track_counts.negative_implicit counts > 0 then (
    if auto_track_count = 0 then
      let iter =
        Seq_ext.repeat Track_sizing_function.auto
        |> Seq.take (Grid_track_counts.negative_implicit counts)
      in
      create_implicit_tracks tracks
        (Grid_track_counts.negative_implicit counts)
        (fun () -> iter ())
        gap
    else
      let offset =
        auto_track_count
        - (Grid_track_counts.negative_implicit counts mod auto_track_count)
      in
      let iter =
        List.to_seq auto_tracks |> Seq_ext.cycle |> Seq.drop offset
        |> Seq.take (Grid_track_counts.negative_implicit counts)
      in
      create_implicit_tracks tracks
        (Grid_track_counts.negative_implicit counts)
        (fun () -> iter ())
        gap;

      let current_track_index =
        ref (Grid_track_counts.negative_implicit counts)
      in

      (* Create explicit tracks *)
      (* An explicit check against the count (rather than just relying on track_template being empty) is required here
     because a count of zero can result from the track_template being invalid, in which case it should be ignored. *)
      if Grid_track_counts.explicit counts > 0 then
        if track_template <> [] then
          List.iter
            (function
              | Template_component.Single sizing_function ->
                  let track =
                    Track_sizing_function.make
                      ~min:
                        (Track_sizing_function.min_sizing_function
                           sizing_function)
                      ~max:
                        (Track_sizing_function.max_sizing_function
                           sizing_function)
                    |> Grid_track.create
                  in
                  tracks := !tracks @ [ track ];
                  tracks := !tracks @ [ Grid_track.gutter gap ];
                  incr current_track_index
              | Template_component.Repeat rep -> (
                  match Repetition.count rep with
                  | Repetition_count.Count count ->
                      let track_list = Repetition.tracks rep in
                      let track_iter =
                        List.to_seq track_list |> Seq_ext.cycle
                        |> Seq.take (Repetition.track_count rep * count)
                      in
                      Seq.iter
                        (fun sizing_function ->
                          let track =
                            Track_sizing_function.make
                              ~min:
                                (Track_sizing_function.min_sizing_function
                                   sizing_function)
                              ~max:
                                (Track_sizing_function.max_sizing_function
                                   sizing_function)
                            |> Grid_track.create
                          in
                          tracks := !tracks @ [ track ];
                          tracks := !tracks @ [ Grid_track.gutter gap ];
                          incr current_track_index)
                        track_iter
                  | Repetition_count.Auto_fit | Repetition_count.Auto_fill ->
                      let auto_repeated_track_count =
                        Grid_track_counts.explicit counts
                        - (List.length track_template - 1)
                      in
                      let track_list = Repetition.tracks rep in
                      let iter =
                        List.to_seq track_list |> Seq_ext.cycle
                        |> Seq.take auto_repeated_track_count
                      in
                      Seq.iter
                        (fun track_def ->
                          let track =
                            Track_sizing_function.make
                              ~min:
                                (Track_sizing_function.min_sizing_function
                                   track_def)
                              ~max:
                                (Track_sizing_function.max_sizing_function
                                   track_def)
                            |> Grid_track.create
                          in
                          let gutter = Grid_track.gutter gap in

                          (* Auto-fit tracks that don't contain should be collapsed. *)
                          let track, gutter =
                            if
                              Repetition.count rep = Repetition_count.Auto_fit
                              && not (track_has_items !current_track_index)
                            then
                              ( Grid_track.collapse track,
                                Grid_track.collapse gutter )
                            else (track, gutter)
                          in

                          tracks := !tracks @ [ track ];
                          tracks := !tracks @ [ gutter ];

                          incr current_track_index)
                        iter))
            track_template;

      let grid_area_tracks =
        Grid_track_counts.negative_implicit counts
        + Grid_track_counts.explicit counts
        - !current_track_index
      in

      (* Create positive implicit tracks *)
      if auto_track_count = 0 then
        let iter =
          Seq_ext.repeat Track_sizing_function.auto
          |> Seq.take
               (Grid_track_counts.positive_implicit counts + grid_area_tracks)
        in
        create_implicit_tracks tracks
          (Grid_track_counts.positive_implicit counts + grid_area_tracks)
          (fun () -> iter ())
          gap
      else
        let iter =
          List.to_seq auto_tracks |> Seq_ext.cycle
          |> Seq.take
               (Grid_track_counts.positive_implicit counts + grid_area_tracks)
        in
        create_implicit_tracks tracks
          (Grid_track_counts.positive_implicit counts + grid_area_tracks)
          (fun () -> iter ())
          gap;

        (* Mark first and last grid lines as collapsed *)
        match !tracks with
        | [] -> ()
        | first :: rest -> (
            tracks := Grid_track.collapse first :: rest;
            match List.rev !tracks with
            | [] -> ()
            | last :: rest_rev ->
                tracks := List.rev (Grid_track.collapse last :: rest_rev)))
