(** explicit_grid.ml
    ---------------------------------------------------------------------------
    Helper functions for initialising GridTrack's from styles This mainly
    consists of evaluating GridAutoTracks
    ---------------------------------------------------------------------------
    SPDX-License-Identifier: MIT OR Apache-2.0
    ---------------------------------------------------------------------------
*)

open Geometry
open Style
open Style.Grid
open Grid_track
open Grid_track_counts
open Grid_grid_axis_helpers

(** Compute the number of rows and columns in the explicit grid *)
let compute_explicit_grid_size_in_axis ~style_size ~style_max_size ~style_gap
    ~template ~inner_container_size ~calc ~axis =
  (* If template contains no tracks, then there are trivially zero explicit tracks *)
  if Array.length template = 0 then 0
  else
    (* If there are any repetitions that contains no tracks, then the whole definition should be considered invalid
       and we default to no explicit tracks *)
    let template_has_repetitions_with_zero_tracks =
      Array.exists
        (function
          | Single _ -> false | Repeat (_, tracks) -> List.length tracks = 0)
        template
    in
    if template_has_repetitions_with_zero_tracks then 0
    else
      (* Compute that number of track generated by single track definition and repetitions with a fixed repetition count *)
      let non_auto_repeating_track_count =
        Array.fold_left
          (fun acc track_def ->
            match track_def with
            | Single _ -> acc + 1
            | Repeat (Count count, tracks) -> acc + (count * List.length tracks)
            | Repeat (Auto_fill, _) | Repeat (Auto_fit, _) -> acc)
          0 template
      in

      let auto_repetition_count =
        Array.fold_left
          (fun acc track_def ->
            match track_def with
            | Repeat (Auto_fill, _) | Repeat (Auto_fit, _) -> acc + 1
            | _ -> acc)
          0 template
      in

      let all_track_defs_have_fixed_component =
        Array.for_all
          (function
            | Single sizing_function -> (
                (* Check if sizing function has fixed component *)
                (match sizing_function.min with
                | Length _ | Percent _ -> true
                | _ -> false)
                ||
                match sizing_function.max with
                | Length _ | Percent _ | Fit_content _ -> true
                | _ -> false)
            | Repeat (_, tracks) ->
                List.for_all
                  (fun (sizing_function :
                         Grid.non_repeated_track_sizing_function) ->
                    (match sizing_function.min with
                    | Grid.Length _ | Grid.Percent _ -> true
                    | _ -> false)
                    ||
                    match sizing_function.max with
                    | Grid.Length _ | Grid.Percent _ | Grid.Fit_content _ ->
                        true
                    | _ -> false)
                  tracks)
          template
      in

      let template_is_valid =
        auto_repetition_count = 0
        || (auto_repetition_count = 1 && all_track_defs_have_fixed_component)
      in

      (* If the template is invalid because it contains multiple auto-repetition definitions or it combines an auto-repetition
         definition with non-fixed-size track sizing functions, then disregard it entirely and default to zero explicit tracks *)
      if not template_is_valid then 0
        (* If there are no repetitions, then the number of explicit tracks is simply equal to the lengths of the track definition
         vector (as each item in the Vec represents one track). *)
      else if auto_repetition_count = 0 then non_auto_repeating_track_count
      else
        (* Find the auto-repetition definition *)
        let repetition_definition =
          Array.find_map
            (function
              | Single _ -> None
              | Repeat (Count _, _) -> None
              | Repeat ((Auto_fit | Auto_fill), tracks) -> Some tracks)
            template
          |> function
          | Some x -> x
          | None -> assert false
        in
        let repetition_track_count = List.length repetition_definition in

        (* Otherwise, run logic to resolve the auto-repeated track count *)
        (* style_size and style_max_size are now parameters *)
        let axis_size =
          match axis with
          | Horizontal -> inner_container_size.width
          | Vertical -> inner_container_size.height
        in

        let style_size_is_definite =
          match
            Dimension.maybe_resolve
              (match axis with
              | Horizontal -> style_size.width
              | Vertical -> style_size.height)
              axis_size calc
          with
          | Some _ -> true
          | None -> false
        in
        let style_max_size_is_definite =
          match
            Dimension.maybe_resolve
              (match axis with
              | Horizontal -> style_max_size.width
              | Vertical -> style_max_size.height)
              axis_size calc
          with
          | Some _ -> true
          | None -> false
        in
        let size_is_maximum =
          style_size_is_definite || style_max_size_is_definite
        in

        (* Determine the number of repetitions *)
        let num_repetitions =
          match axis_size with
          | None -> 1
          | Some inner_container_size ->
              let parent_size = Some inner_container_size in

              (* ...treating each track as its max track sizing function if that is definite or as its minimum track sizing function
                 otherwise, flooring the max track sizing function by the min track sizing function if both are definite *)
              let track_definite_value
                  (sizing_function :
                    Style.Grid.non_repeated_track_sizing_function) =
                let max_size =
                  Grid_helpers.MaxSizing.definite_value sizing_function.max
                    parent_size calc
                in
                let min_size =
                  match
                    (sizing_function.min : Style.Grid.min_track_sizing_function)
                  with
                  | Length px -> Some px
                  | Percent pct -> (
                      match parent_size with
                      | Some p -> Some (p *. pct)
                      | None -> None)
                  | Auto | Min_content | Max_content -> None
                in
                match (max_size, min_size) with
                | Some max, Some min -> Float.max max min
                | Some max, None -> max
                | None, Some min -> min
                | None, None ->
                    0.0 (* This shouldn't happen with valid tracks *)
              in

              let non_repeating_track_used_space =
                Array.fold_left
                  (fun acc track_def ->
                    match track_def with
                    | Single sizing_function ->
                        acc +. track_definite_value sizing_function
                    | Repeat (Count count, repeated_tracks) ->
                        let sum =
                          List.fold_left
                            (fun s sf -> s +. track_definite_value sf)
                            0.0 repeated_tracks
                        in
                        acc +. (sum *. float_of_int count)
                    | Repeat ((Auto_fit | Auto_fill), _) -> acc)
                  0.0 template
              in

              let gap_size =
                let gap = style_gap in
                match axis with
                | Horizontal ->
                    Dimension.resolve_or_zero gap.width
                      (Some inner_container_size) calc
                | Vertical ->
                    Dimension.resolve_or_zero gap.height
                      (Some inner_container_size) calc
              in

              (* Compute the amount of space that a single repetition of the repeated track list takes *)
              let per_repetition_track_used_space =
                List.fold_left
                  (fun acc sf -> acc +. track_definite_value sf)
                  0.0 repetition_definition
              in

              (* We special case the first repetition here because the number of gaps in the first repetition
                 depends on the number of non-repeating tracks in the template *)
              let first_repetition_and_non_repeating_tracks_used_space =
                non_repeating_track_used_space
                +. per_repetition_track_used_space
                +. float_of_int
                     (max 0
                        (non_auto_repeating_track_count + repetition_track_count
                       - 1))
                   *. gap_size
              in

              (* If a single repetition already overflows the container then we return 1 as the repetition count
                 (the number of repetitions is floored at 1) *)
              if
                first_repetition_and_non_repeating_tracks_used_space
                > inner_container_size
              then 1
              else
                let per_repetition_gap_used_space =
                  float_of_int repetition_track_count *. gap_size
                in
                let per_repetition_used_space =
                  per_repetition_track_used_space
                  +. per_repetition_gap_used_space
                in
                let num_repetition_that_fit =
                  (inner_container_size
                 -. first_repetition_and_non_repeating_tracks_used_space)
                  /. per_repetition_used_space
                in

                (* If the container size is a preferred or maximum size:
                     Then we return the maximum number of repetitions that fit into the container without overflowing.
                   If the container size is a minimum size:
                     Then we return the minimum number of repetitions required to overflow the size.
                   
                   In all cases we add the additional repetition that was already accounted for in the special-case computation above *)
                if size_is_maximum then
                  int_of_float (floor num_repetition_that_fit) + 1
                else int_of_float (ceil num_repetition_that_fit) + 1
        in

        non_auto_repeating_track_count
        + (repetition_track_count * num_repetitions)

(** Utility function for repeating logic of creating implicit tracks *)
let create_implicit_tracks count auto_tracks_iter gap =
  let tracks = ref [] in
  for _ = 1 to count do
    let track_def = auto_tracks_iter () in
    tracks :=
      !tracks
      @ [ Grid_track.create track_def.min track_def.max; Grid_track.gutter gap ]
  done;
  !tracks

(** Resolve the track sizing functions of explicit tracks, automatically created
    tracks, and gutters given a set of track counts and all of the relevant
    styles *)
let initialize_grid_tracks ~counts ~track_template ~auto_tracks ~gap
    ~track_has_items =
  (* Reserve space for all tracks ahead of time to reduce allocations *)
  let total_tracks =
    ((counts.negative_implicit + counts.explicit + counts.positive_implicit) * 2)
    + 1
  in
  let tracks = Array.make total_tracks (gutter gap) in
  let track_idx = ref 0 in

  (* Helper to add a track *)
  let add_track track =
    tracks.(!track_idx) <- track;
    incr track_idx
  in

  (* Initial gutter *)
  add_track (gutter gap);

  (* Create negative implicit tracks *)
  (if counts.negative_implicit > 0 then
     if Array.length auto_tracks = 0 then
       for _ = 1 to counts.negative_implicit do
         add_track (create Auto Auto);
         add_track (gutter gap)
       done
     else
       let auto_len = Array.length auto_tracks in
       let offset = auto_len - (counts.negative_implicit mod auto_len) in
       for i = 0 to counts.negative_implicit - 1 do
         let idx = (offset + i) mod auto_len in
         let track_def = auto_tracks.(idx) in
         add_track (create track_def.min track_def.max);
         add_track (gutter gap)
       done);

  let current_track_index = ref counts.negative_implicit in

  (* Create explicit tracks *)
  if counts.explicit > 0 then
    Array.iter
      (function
        | Single sizing_function ->
            add_track (create sizing_function.min sizing_function.max);
            add_track (gutter gap);
            incr current_track_index
        | Repeat (Count count, repeated_tracks) ->
            for _ = 1 to count do
              List.iter
                (fun sizing_function ->
                  add_track (create sizing_function.min sizing_function.max);
                  add_track (gutter gap);
                  incr current_track_index)
                repeated_tracks
            done
        | Repeat (repetition_kind, repeated_tracks) ->
            let auto_repeated_track_count =
              counts.explicit - (Array.length track_template - 1)
            in
            let repeated_tracks_array = Array.of_list repeated_tracks in
            let repeated_len = Array.length repeated_tracks_array in
            for i = 0 to auto_repeated_track_count - 1 do
              let track_def = repeated_tracks_array.(i mod repeated_len) in
              let track = create track_def.min track_def.max in
              let gutter_track = gutter gap in

              (* Auto-fit tracks that don't contain should be collapsed. *)
              if
                repetition_kind = Auto_fit
                && not (track_has_items !current_track_index)
              then (
                collapse track;
                collapse gutter_track);

              add_track track;
              add_track gutter_track;
              incr current_track_index
            done)
      track_template;

  (* Create positive implicit tracks *)
  if Array.length auto_tracks = 0 then
    for _ = 1 to counts.positive_implicit do
      add_track (create Auto Auto);
      add_track (gutter gap)
    done
  else
    for i = 0 to counts.positive_implicit - 1 do
      let track_def = auto_tracks.(i mod Array.length auto_tracks) in
      add_track (create track_def.min track_def.max);
      add_track (gutter gap)
    done;

  (* Mark first and last grid lines as collapsed *)
  collapse tracks.(0);
  collapse tracks.(Array.length tracks - 1);

  tracks
